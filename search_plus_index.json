{"./":{"url":"./","title":"序言","keywords":"","body":"Blockchain 学习笔记 本系列是 Blockchain 学习笔记 更多的学习笔记请参考： Kubernetes 学习笔记 Golang 学习笔记 Linux 学习笔记 数据结构学习笔记 个人博客：www.huweihuang.com 目录 前言 序言 区块链 区块链系列（四）之密钥和地址 区块链系列（五）之比特币钱包 区块链系列（六）之比特币交易 区块链系列（八）之区块链介绍 区块链系列（九）之挖矿与共识 区块链系列（十）之共识算法 以太坊 以太坊系列（一）之以太坊介绍 以太坊系列（二）之账户管理 赞赏 如果觉得文章有帮助的话，可以打赏一下，谢谢！ Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"blockchain/blockchain-keys&addresses.html":{"url":"blockchain/blockchain-keys&addresses.html","title":"密钥和地址","keywords":"","body":"区块链系列（四）之密钥和地址 1. 比特币密钥 比特币的所有权是通过数字密钥、比特币地址和数字签名来确定的，数字密钥不存在网络中，而由用户生成，存储在一个文件或简单的数据库中，一般称之为钱包。 比特币交易都需要一个有效的签名才会被存储到区块链中，只有有效的密钥才能产生有效的数字签名，因此拥有密钥副本就拥有了该账户的比特币控制权。 密钥是成对出现的，由公钥和私钥组成。公钥类似银行账号，私钥类似支票签名。在比特币交易环节， 收款人的公钥是通过数字指纹代表的，称之为比特币地址，类似支票上的收款方。一般情况，比特币地址由一个公钥生成并对应于这个公钥。 1.1. 公钥加密和加密货币 比特币使用椭圆曲线算法作为公钥加密的基础，椭圆曲线算法是一个不可逆的函数，即可以由A生成B，但不能由B推导出A。 在比特币系统中，用公钥加密创建一个密钥对，用于控制比特币的获取。密钥对包括一个私钥和由其衍生的唯一公钥。公钥用于接收比特币，私钥用于比特币支付时的交易签名。由私钥生产的签名可以在不泄露私钥的同时对公钥进行验证。 支付比特币时，比特币的当前所有者需要在交易中提交其公钥和签名，比特币的所有人都可以通过提交的公钥和签名验证该交易是否有效，即确认支付者在该时刻对所交易的比特币拥有所有权。 1.2. 私钥和公钥 比特币包含一系列密钥对，每个密钥对包含一个公钥和私钥。私钥是一个随机数，私钥通过椭圆曲线算法生成公钥，公钥再通过单向加密哈希函数生成比特币地址。比特币使用非对称加密，使得签名只能由私钥产生，且在不泄露私钥情况下所有人都可以验证该签名p。 1.3. 私钥 私钥可以理解为一个随机数，比特币地址中资金的控制取决于相应私钥的控制权，比特币交易中，私钥用于生成支付比特币所必需的签名以证明对资金的所有权。 从随机数生成私钥 选择随机性来源（熵源），生成一个比特币私钥在本质上与“在1到$2^{256}$之间选一个数字”无异。建议使用密码学安全的伪随机数生成器（CSPRNG），并且需要有一个来自具有足够熵值的源的种子。 1.4.公钥 通过椭圆曲线算法可以由私钥生成公钥，该过程是不可逆的过程：K（公钥）=k（私钥）*G（常数点）。其反向运算，被称为“寻找离散对数”——已知公钥K来求出私钥k——是极其困难的。 1.5. 椭圆曲线算法 椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥）加密法，可以用对椭圆曲线上的点进行加法或乘法运算来表达。 比特币使用了secp256k1标准所定义的一条特殊的椭圆曲线和一系列数学常数。 secp256k1曲线由下述函数定义，该函数可产生一条椭圆曲线： y2 = (x3 + 7)} over (Fp) 或 y2 mod p = (x3 + 7) mod p 上述mod p（素数p取模）表明该曲线是在素数阶p的有限域内，也写作Fp，其中p = 2256 – 232 – 29 – 28 – 27 – 26 – 24 – 1，这是一个非常大的素数。 在椭圆曲线中，点的相加等同于从该点画切线找到与曲线相交的另一点，然后映射到x轴。 1.6. 生成公钥 以一个随机生成的私钥k为起点，将其与曲线上已定义的生成点G相乘以获得曲线上的另一点，也就是相应的公钥K。生成点是secp256k1标准的一部分，比特币密钥的生成点都是相同的，所以一个私钥k对应唯一的一个公钥K，只能单向运算，即不能由公钥K得出私钥k。 {K = k * G} 示例： K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G K = (x, y) 其中， x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 2. 比特币地址 比特币地址是一个由数字和字母组成的字符串，可以公开，由公钥生成的比特币地址一般以数字1开头。 例如：1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy 在比特币交易中，比特币地址一般用来表示收款方。 比特币地址由公钥经过单向加密哈希算法得到，哈希算法是一种单向函数，接收任意长度的输入产生指纹摘要。由公钥生成比特币地址时使用的算法如下： Secure Hash Algorithm (SHA) the RACE Integrity Primitives Evaluation Message Digest (RIPEMD)， 特别是SHA256和RIPEMD160。 示例： # K是公钥，A是生成的比特币地址。 A = RIPEMD160(SHA256(K)) 通常用户见到的比特币地址是经过Base58Check编码的，该编码使用了58个字符（一种Base58数字系统）和校验码，提高了可读性、避免歧义并有效防止了在地址转录和输入中产生的错误。 由公钥生成比特币地址的过程： 2.1. Base58和Base58Check编码 2.1.1. Base58 Base58是一种基于文本的二进制编码格式，用在比特币和其它的加密货币中。 特点： 数据压缩 易读性 错误诊断功能 Base58是Base64编码格式的子集，使用大小写字母和10个数字，舍弃了一些容易错读和在特定字体中容易混淆的字符。Base58不含Base64中的0（数字0）、O（大写字母o）、l（小写字母L）、I（大写字母i），以及“+”和“/”两个字符。 即Base58就是由不包括（0，O，l，I）的大小写字母和数字组成（26+26+10-4=58）。 比特币的Base58字母表 123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz 2.1.2. Base58Check Base58Check编码：一种Base58格式的、有版本的、经过校验的格式，可以明确的对比特币数据编码的编码格式。 Base58Check编码增加了错误校验码来检查数据在转录中出现的错误。校验码长4个字节，添加到需要编码的数据之后。校验码是从需要编码的数据的哈希值中得到的，所以可以用来检测并避免转录和输入中产生的错误。 示例： checksum = SHA256(SHA256(prefix+data)) 结果由三部分组成：前缀、数据和校验码。 Base58Check编码的过程 Base58Check版本前缀和编码后的结果 种类 版本前缀 (hex) Base58格式 Bitcoin Address 0x00 1 Pay-to-Script-Hash Address 0x05 3 Bitcoin Testnet Address 0x6F m or n Private Key WIF 0x80 5, K or L BIP38 Encrypted Private Key 0x0142 6P BIP32 Extended Public Key 0x0488B21E xpub 2.2. 密钥的格式 公钥和私钥的都可以有多种编码格式。一个密钥被不同的格式编码后，虽然结果看起来可能不同，但是密钥所编码数字并没有改变。这些不同的编码格式主要是用来方便人们无误地使用和识别密钥。 2.2.1. 私钥的格式 私钥可以以许多不同的格式表示，所有这些都对应于相同的256位的数字。 1）私钥表示法（编码格式） 种类 版本 描述 Hex None 64 hexadecimal digits WIF 5 Base58Check encoding: Base58 with version prefix of 128 and 32-bit checksum WIF-compressed K or L As above, with added suffix 0x01 before encoding 2）同样的私钥，不同的格式 以下展示了用这三种格式所生成的私钥。 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 这些表示法都是用来表示相同的数字、相同的私钥的不同方法。虽然编码后的字符串看起来不同，但不同的格式彼此之间可以很容易地相互转换。 3）不同编码格式的转换 将Base58Check编码解码为十六进制 $ sx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 将十六进制转换为Base58Check编码 $sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 128 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn 将十六进制（压缩格式密钥）转换为Base58Check编码 $ sx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 128 KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 2.2.2. 公钥的格式 公钥也可以用不同的格式来表示，主要分为非压缩格式和压缩格式两种形式。 公钥是在椭圆曲线上的一个点，由一对坐标（x，y）组成。公钥通常表示为前缀04紧接着两个256比特的数字。其中一个256比特数字是公钥的x坐标，另一个256比特数字是y坐标。前缀04是用来区分非压缩格式公钥，压缩格式公钥是以02或者03开头。 公钥的组成格式：04 示例： # x,y值 x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB # 公钥K K=04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB 1）压缩格式公钥 压缩格式公钥主要为了减少比特币交易的字节数，节省运行区块链数据库节点的磁盘空间。原先公钥有520比特（包括前缀，x坐标，y坐标）。公钥是椭圆曲线上（y2mod p = (x3 + 7) mod p）的一个点（x,y），已知x坐标，可以解方程得出y，即可省去y坐标的存储，可以减少一半字节数的存储。 压缩格式公钥的前缀是02和03，因为解方程的y值有正数和负数两个值，当我们在素数p阶的有限域上使用二进制算术计算椭圆曲线的时候，y坐标可能是奇数或者偶数，分别对应前面所讲的y值的正负符号。为了区分y坐标的两种可能值，我们在生成压缩格式公钥时，如果y是偶数，则使用02作为前缀；如果y是奇数，则使用03作为前缀。 示例： # 前缀03，表示y坐标是奇数 K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A 公钥压缩示意图： 2）压缩格式私钥 压缩的私钥实际上只是表示“用于生成压缩格式公钥的私钥”，而非压缩格式私钥用来表明“用于生成非压缩格式公钥的私钥”。当一个私钥被使用WIF压缩格式导出时，不但没有压缩，而且比“非压缩格式”私钥长出一个字节。 同样的私钥，不同的格式 格式 私钥 Hex 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD WIF 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn Hex-compressed 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD01 WIF-compressed KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ 参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch04.asciidoc Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"blockchain/blockchain-wallets.html":{"url":"blockchain/blockchain-wallets.html","title":"比特币钱包","keywords":"","body":"区块链系列（五）之比特币钱包 1. 钱包技术概述 钱包从广义上来讲是一个应用程序，管理密钥和地址，跟踪余额以及创建和签名交易；从狭义上来讲，钱包是指用于存储和管理用户密钥的数据结构，是私钥的容器。 比特币钱包里面不含有比特币，而是含有比特币的密钥链（即可能含有多个密钥对），比特币则是被记录在比特币网络的区块链中。用户用密钥签名交易，证明他们拥有交易输出（他们的钱币），钱币以交易输出的方式存储在区块链中。 根据钱包内的多个密钥之间是否相互关联，将钱包分为两种类型： 非确定性钱包：钱包内多个密钥之间没有关联，每个密钥都是随机数产生。 确定性钱包：钱包内多个密钥之间相互关联，钱包内的所有密钥都是由主密钥派生出来的，主密钥称为种子密钥，有主密钥可以生成全部密钥。种子密钥一般被编码成英文单词，称为助记词。 1.1. 非确定性钱包 钱包是随机生成的密钥的集合，密钥之间没有关联，所有的密钥都需要备份它的副本，避免密钥丢失而钱包的资金丢失，非确定性钱包难以管理、备份和导入，因此不推荐使用。 1.2. 确定性钱包 确定性钱包是由种子密钥通过单向离散函数生成其他子密钥的钱包，而种子密钥是随机生成的。种子密钥可以恢复所有已经产生的密钥，因此只需要对种子密钥进行备份和管理即可。 1.3. 分层确定性钱包（HD Wallets (BIP-32/BIP-44)） 分层确定性钱包又称HD钱包，HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列的子密钥，子密钥衍生孙密钥。 HD钱包的优势： 树状组织结构可以用来额外表达组织含义，例如一个分支用来付款，一个分支用来收款。 可以创建一个公共密钥序列而不需要访问相对应的私钥，这可允许HD钱包在不安全的服务器中使用或者在每笔交易中发行不同的公共钥匙。 1.4. 种子密钥和助记词 由一系列英文单词生成种子密钥，这些英文单词被称为助记词，标准由BIP-39定义。目前大多数加密货币钱包通过助记词的方式进行备份恢复和转移。 助记词示例如下: army van defense carry jealous true garbage claim echo media make crunch 1.5. 钱包的最佳实践 比特币钱包的常用标准： 助记词，基于BIP-39 HD钱包，基于BIP-32 多用途HD钱包结构，基于BIP-43 多币种和多账户钱包，基于BIP-44 如果开发比特币钱包，一般要遵循BIP-32、BIP-39、BIP-43和BIP-44标准，构建为HD钱包，通过助记词生成种子密钥进行备份。 2. 钱包技术细节 2.1. 助记码词汇（BIP-39） 助记码词汇是英文单词序列代表用作种子对应确定性钱包的随机数，即由钱包随机生成的，单词及其顺序确定了一组助记词，通过助记词可以创建和恢复钱包及其所有私钥。BIP-39定义了助记词和种子的创建，此处分为九个步骤，1-6是创建助记词，7-9是从助记词创建种子。 2.2. 创建助记词 助记词是由钱包使用BIP-39中定义的标准化过程自动生成的。 钱包从熵源开始，增加校验和，然后将熵映射到单词列表： 1、创建一个128到256位的随机序列（熵）。 2、提出SHA256哈希前几位（熵长/ 32），就可以创造一个随机序列的校验和。 3、将校验和添加到随机序列的末尾。 4、将序列划分为包含11位的不同部分。 5、将每个包含11位部分的值与一个已经预先定义2048个单词的字典做对应。 6、生成的有顺序的单词组就是助记码。 参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch05.asciidoc Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"blockchain/blockchain-transactions.html":{"url":"blockchain/blockchain-transactions.html","title":"比特币交易","keywords":"","body":"区块链系列（六）之比特币交易 1. 比特币交易简介 比特币交易是比特币系统最重要的部分，本质是数据结构，数据结构中含有比特币交易参与者价值转移的相关信息。比特币区块链是一本全球复制记账总账簿，每个比特币交易即账簿上公开的一页转账记录。 2. 比特币交易的生命周期 创建比特币交易，通过一个或多个签名加密，签名标志了该比特币的使用许可。 交易广播到比特币网络中，每个节点进行验证，并进行广播，直到该交易被大多数节点接收。 比特币交易被一个挖坑节点验证，并被添加到区块链一个记录多笔交易的区块中。 一个交易如果被记录到区块链上并被足够多的后续区块确认，便成为比特币总账簿的一部分，并被所有比特币交易参与者认可为有效交易。 2.1. 创建比特币交易 比特币交易类似纸质支票，比特币交易带有货币转移的目的，交易可以被任何人在线上或线下创建，但是交易的发起人并不一定是签署该笔交易的人，比如一个负责应付账款的柜员发起交易，但需要CEO进行签名才有效。比特币交易的资金来源是以往的某笔交易输入，而不是一个特定账户。 一笔比特币交易被创建，会被所有资金所有者签名，如果是合法创建和签名，则该交易是有效的。 2.2. 广播交易至比特币网络 一笔交易需要传递到比特币网络中，才能被传播也才能加入区块链中。本质上比特币交易是一份数据，并且需要被发送到比特币节点的任何一个。该交易经过签名但不含任何机密信息、私钥等，因此可以被公开传播。 2.3. 比特币交易在比特币网络中传播 比特币交易被发送到比特币网络的任一节点，该节点将会验证该笔交易。具体如下： 如果验证为有效，则广播该交易至其他连接节点；交易发起者会接收到表示交易有效并被接受的返回信息。 如果验证为无效，则拒绝该交易；交易发起者会接收到交易被拒绝的信息。 比特币网络是个点对点网络，每个比特币节点都可以连接其他节点。整个比特币网络形成松散连接，没有固定拓扑的网状结构，所以节点地位同等。一笔有效的交易被验证后会被传播到其他节点，以此类推，交易会被迅速扩散式传播，直到所有节点都接收到它。 每个节点在传播每笔交易前均进行独立验证，因此比特币网络可以抵御入侵，拒绝服务式攻击等。 3. 交易结构 一笔比特币交易是一个包含输入值和输出值的数据结构，该数据结构植入了将一笔资金从起始点（输入值）转移至目标地址（输出值）的代码信息。比特币交易的输入值和输出值与账户或身份信息无关。 交易结构 大小 字段 描述 4字节 版本 明确这笔交易参照的规则 1-9字节 输入数量 被包含的输入的数量 不定 输入 一个或多个交易输入 1-9字节 输出数量 被包含的输出的数量 不定 输出 一个或多个交易输出 4字节 时钟时间 一个UNIX时间戳或区块号 4. 交易的输出和输入 比特币交易的基本单位是一个未花费的输出（UTXO），UTXO是不能分割，被记录于区块链中并被整个网络识别成货币单位的一定量的比特币货币。比特币没有账户和余额的概念，只有分散到区块链中的UTXO。比特币的余额是比特币钱包通过扫描区块链并聚合所有属于该用户的UTXO来计算该用户余额。 比特币可以分成表示八位小数的聪，一个UTXO可以是一“聪”的任意倍，UTXO虽然可以是任意值但一旦被创造出来就不能被切分。就好比，用5元纸币支付2元的商品，不能将5元撕成一半支付，而是支付5元，找零3元。比特币钱包可以自动通过组合若干UTXO来准确支付或找零。 被交易消耗的UTXO被称为交易输入，被交易创建的UTXO称为交易输出。通过不断在交易链中消耗和创建UTXO，实现比特币价值在不同所有者之间转移。一笔比特币交易通过使用所有者的签名来解锁UTXO，通过新的使用者的比特币地址来锁定并创建UTXO。 4.1. 交易输出 每一笔比特币交易创造输出，输出都会被比特币账簿记录下来。几乎所有的输出都能创造一定数量的可用于支付的比特币，也就是UTXO。这些UTXO被整个网络识别，并且所有者可在未来的交易中使用它们。给某人发送比特币实际上是创造新的UTXO，注册到那个人的地址，并且能被他用于新的支付。 UTXO被每一个全节点比特币客户端在一个储存于内存中的数据库所追踪，该数据库也被称为“UTXO集”或者“UTXO池”。新的交易从UTXO集中消耗（支付）一个或多个输出。 交易输出包含两部分： 一定量的比特币，被命名为“聪”，是最小的比特币单位； 一个锁定脚本，也被当作是“障碍”，提出支付输出所必须被满足的条件以“锁住”这笔总额。 交易输出结构 尺寸 字段 说明 8个字节 总量 用聪表示的比特币值（10-8比特币） 1–9个字节（可变整数） 锁定脚本尺寸 用字节表示的后面的锁定脚本长度 变长 锁定脚本 一个定义了支付输出所需条件的脚本 支付条件（障碍） 交易输出把用聪表示的一定数量的比特币，和特定的定义了支付输出所必须被满足的条件的障碍，或者叫锁定脚本，关联到了一起。在大多数情况下，锁定脚本会把输出锁在一个特定的比特币地址上，从而把一定数量的比特币的所有权转移到新的所有者上。 4.2. 交易输入 交易输入是指向UTXO的指针。它们指向特定的UTXO，并被交易哈希和在区块链中记录UTXO的序列号作为参考。若想支付UTXO，一个交易的输入也需要包含一个解锁脚本，用来满足UTXO的支付条件。解锁脚本通常是一个签名，用来证明对于在锁定脚本中的比特币地址拥有所有权。 当用户付款时，他的钱包通过选择可用的UTXO来构造一笔交易。比如说，要支付0.015比特币，钱包应用会选择一个0.01 UTXO和一个0.005 UTXO，使用它们加在一起来得到想要的付款额。 一旦UTXO被选中，钱包会为每个UTXO生成包含签名的解锁脚本，由此让它们变得可以通过满足锁定脚本的条件来被支付。钱包把这些UTXO作为参考，并且连同解锁脚本一起作为输入加到交易中。 交易输入的结构 尺寸 字段 说明 32个字节 交易 指向交易包含的被花费的UTXO的哈希指针 4个字节 输出索引 被花费的UTXO的索引号，第一个是0 1–9个字节（可变整数） 解锁脚本尺寸 用字节表示的后面的解锁脚本长度 变长 解锁脚本 一个达到UTXO锁定脚本中的条件的脚本 4个字节 序列号 目前未被使用的交易替换功能，设成0xFFFFFFFF 4.3. 交易费 交易费可当作是为了包含（挖矿）一笔交易到下一个区块中的一种鼓励，也可当作是对于欺诈交易和任何种类的系统滥用，在每一笔交易上通过征收一笔小成本的税而造成的一种妨碍。交易费被挖出这个区块的矿工得到，并且记录在这个交易的区块链中。 交易费基于交易的尺寸，用千字节来计算，与参加交易的比特币值无关。总的来说，交易费基于市场所设置，生效于比特币网络中。 交易费的高低影响交易被处理的优先级，即交易费高的交易可以被优先处理，交易费低的交易被延迟处理，甚至不被处理。 4.4. 把交易费加到交易中 交易的数据结构没有交易费的字段，而是输入总额与输出总额之间的差来表示。 交易费 = 求和（所有输入） - 求和（所有输出） 当一笔交易需要找零时，交易费 = 付款金额 - 收款金额 - 找零金额。 5. 交易链条和孤立交易 交易形成一条链，这条链的形式是一笔交易消耗了先前的交易（父交易）的输出，并为随后的交易（子交易）创造了输出。 有的时候组成整个链条的所有交易依赖于他们自己——比如父交易、子交易和孙交易——而他们又被同时创造出来，来满足复杂交易的工作流程。这需要在一个交易的父交易被签名之前，有一个合法的子交易被签名。 当父交易和子交易同时被创建的时候，如果子交易比父交易先到达目的地，验证的时候找不到父交易，此时子交易会被放到临时池中（没有父交易的交易池称为孤立交易池），一旦接收到父交易，孤立池的子交易就会被释放出来，递归重新验证。 内存中储存的孤立交易数量是有限制的，避免拒绝服务攻击（DoS）。最大值为MAX_ORPHAN_TRANSACTIONS，如果超过该值，会随机选出一个或多个孤立交易丢弃，直到交易数低于该值。 6. 比特币交易脚本和脚本语言 比特币客户端通过执行一个用类Forth脚本语言编写的脚本验证比特币交易。锁定脚本被写入UTXO，同时它往往包含一个用同种脚本语言编写的签名。当一笔比特币交易被验证时，每一个输入值中的解锁脚本被与其对应的锁定脚本同时（互不干扰地）执行，从而查看这笔交易是否满足使用条件。 6.1. 脚本创建（锁定和解锁） 比特币的交易验证引擎依赖于两类脚本来验证比特币交易：一个锁定脚本和一个解锁脚本。 锁定脚本是一个放在一个输出值上的“障碍”，同时它明确了今后花费这笔输出的条件。由于锁定脚本往往含有一个公钥（即比特币地址）。 解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，同时它将允许输出被消费。解锁脚本是每一笔比特币交易输出的一部分，而且往往含有一个被用户的比特币钱包（通过用户的私钥）生成的数字签名。由于解锁脚本常常包含一个数字签名，因此它曾被称作ScriptSig。 每一个比特币客户端会通过同时执行锁定和解锁脚本来验证一笔交易。对于比特币交易中的每一个输入，验证软件会先检索输入所指向的UTXO。这个UTXO包含一个定义了花费条件的锁定脚本。接下来，验证软件会读取试图花费这个UTXO的输入中所包含的解锁脚本，并执行这两个脚本。 使用堆栈执行引擎执行解锁脚本。如果解锁脚本在执行过程中未报错（没有悬空操作符），主堆栈（非其它堆栈）将被复制，然后脚本将被执行。如果采用从解锁脚本处复制而来的数据执行锁定脚本的结果为真，那么解锁脚本就成功地满足了锁定脚本所设置的条件，因而，该输入是一个能使用该UTXO的有效授权。如果在执行完组合脚本后的结果不是真，那么输入就不是有效的，因为它并未能满足UTXO中所设置的使用该笔资金的条件。 UTXO是永久性地记录在区块链中的，因此它不会因一笔新交易所发起的无效尝试而变化或受影响。只有一笔有效的能准确满足UTXO条件的交易才会导致UTXO被标记为“已使用”，然后从有效的（未使用）UTXO集中所移除。 解锁和锁定脚本样本 图片 - scriptSig 6.2. 脚本语言 比特币脚本语言被称为基于栈语言，因为它使用的数据结构被称为栈。脚本语言通过从左至右地处理每个项目的方式执行脚本。数字（常数）被推送至堆栈，操作符向堆栈推送（或移除）一个或多个参数，对它们进行处理，甚至可能会向堆栈推送一个结果。 6.3. 图灵非完备性 比特币脚本语言没有循环或者复杂流控制功能以外的其他条件的流控制。即图灵非完备性，这意味着脚本的复杂性有限，交易可执行的次数有限。这种限制避免受到拒绝服务攻击。 6.4. 非主权验证 比特币交易脚本语言是无国家主权的，一个脚本能在任何系统上以相同的方式执行。如果你的系统对一个脚本进行验证，可以确信的是每一个比特币网络中的其他系统也将对其进行验证，这意味着一个有效的交易对每个人而言都是有效的。 7. 标准交易 比特币发展中，开发者对可以经由客户端进行操作的脚本类型设置了一些限制。这些限制被编译为一个Standard（）函数，该函数定义了五种类型的标准交易。五大标准脚本分别为P2PKH、P2PK、MS（限15个密钥）[多重签名]、P2SH和OP_Return。 7.1. 多重签名 多重签名脚本设置了这样一个条件，假如记录在脚本中的公钥个数为N，则至少需提供其中的M个公钥才可以解锁。这也被称为M-N组合，其中，N是记录在脚本中的公钥总个数，M是使得多重签名生效的公钥数阀值（最少数目）。 参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch06.asciidoc Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"blockchain/blockchain-introduction.html":{"url":"blockchain/blockchain-introduction.html","title":"区块链介绍","keywords":"","body":"区块链系列（八）之区块链介绍 1. 区块链简介 1.1. 区块链的概念 区块链是一个去中心化的分布式数据库，该数据库由一串使用密码学方法产生的数据区块有序链接而成，区块中包含有一定时间内产生的无法被篡改的数据记录信息。 区块中包含了数据记录、当前区块根Hash、前一个区块根Hash、时间戳以及其他信息。数据记录的类型可以根据场景决定，比如为资产交易记录、资产发行记录等。 从技术层面看，区块链是一个基于共识机制、去中心化的公开数据库，可以理解为分布式账本。 共识机制：指在分布式系统中保证数据一致性的算法。 去中心化：指参与区块链的所有节点都是权力对等的，所有人可以平等自由地参与区块链网络。 公开数据库：指所有人都可以看到过完的区块和交易，这也保证了造假和改写。 从价值层面看，区块链是一个价值互联网，用于传递价值。现有的互联网是一个信息互联网，基于TCP/IP协议传递信息。 1.2. 区块链的分类 1、公共区块链 公共区块链（Public Blockchain）:指全世界任何人都可读取、可发送交易进行有效性确认，任何人都能参与其共识过程的区块链。公共区块链上的数据记录公开，共识过程的参与者通过密码学技术共同维护区块链数据的安全、透明、不可篡改。 公共区块链是完全分布式的区块链，区块链数据公开，用户参与程度高，易产生网络效应，便于推广。 公共区块链的典型应用有比特币、以太坊等。 2、联盟区块链 联盟（行业）区块链（Consortium Blockchain）:指参与区块链的节点是事先选择好的，节点间通常有良好的网络连接等合作关系，区块链上的数据可以是公开也可以是内部的，为部分意义上的分布式，可视为“部分去中心化”。 3、私有区块链 私有区块链（Private Blockchain）:参与的节点只有有限的范围，比如特定机构的自身用户，数据的访问及使用有严格的权限管理。完全私有的区块链中写入权限仅在参与者手里，读取权限可以对外开放，也可以被任意程度地限制。 1.3. 区块链的层次模型 区块链系统自下而上可分为六层结构：数据层、网络层、共识层、激励层、合约层和应用层。其中，数据层、网络层、共识层是区块链的必要元素，激励层、合约层、应用层不是区块链的必要元素。 数据层：作为最底层封装了数据区块以及相关数据加密和时间戳等技术。 网络层：包括分布式组网机制、数据传播机制和数据验证机制等。 共识层：主要封装网络节点的各类共识算法。 激励层：它将经济因素集成到区块链技术体系，包括经济激励的发行机制和分配机制，主要出现在公链中。 合约层：它封装各种脚本、算法和智能合约。 应用层：封装了区块链的各种应用场景和案例。 2. 区块结构 区块是一种被包含在公开账簿（区块链）里的聚合了交易信息的容器数据结构。它由一个包含元数据的区块头和紧跟其后的构成区块主体的一长串交易组成。区块头是80字节，而平均每个交易至少是250字节，而且平均每个区块至少包含超过500个交易。因此，一个包含所有交易的完整区块比区块头的1000倍还要大。 区块结构 大小 字段 描述 4字节 区块大小 用字节表示的该字段之后的区块大小 80字节 区块头 组成区块头的几个字段 1-9 （可变整数） 交易计数器 交易的数量 可变的 交易 记录在区块里的交易信息 3. 区块头 区块头由三组区块元数据组成。 第一组引用父区块哈希值的数据，用于将该区块与区块链中前一区块相连接。 第二组元数据，即难度、时间戳和nonce，与挖矿竞争相关。 第三组元数据是merkle树根（一种用来有效地总结区块中所有交易的数据结构）。 区块头结构 大小 字段 描述 4字节 版本 版本号，用于跟踪软件/协议的更新 32字节 父区块哈希值 引用区块链中父区块的哈希值 32字节 Merkle根 该区块中交易的merkle树根的哈希值 4字节 时间戳 该区块产生的近似时间（精确到秒的Unix时间戳） 4字节 难度目标 该区块工作量证明算法的难度目标 4字节 Nonce 用于工作量证明算法的计数器 4. 区块标识符：区块头哈希值和区块高度 4.1. 区块头哈希值 区块哈希值是通过SHA256算法对区块头进行二次哈希获得，作为区块的主标识符，可以唯一、明确地标识一个区块，任何节点通过对区块头进行哈希计算都可以获取该区块哈希值。 区块哈希值并不包含在区块的数据结构中，而是当区块被网络接收时由每个节点计算出来的。区块哈希值可能会作为区块元数据的一部分被存储在一个独立的数据表中方便更快的检索区块。 4.2. 区块高度 区块高度表示区块在区块链中的位置，即距离第一个区块的位置。第一个区块的区块高度定义为0，后续的区块高度在此基础上依次递增。可以类比为一个从低到高堆叠的箱子，第一个箱子的高度为0。 区块高度并不是区块的唯一标识符，因为可能出现区块链分叉，导致同一个高度有2个或多个区块。即一个区块有唯一的一个区块高度，但一个区块高度不对应唯一的一个区块。 区块高度也不包含在区块数据结构中，当节点接收到比特币网络的区块时会动态识别该区块的区块高度。区块高度也可作为元数据存储在一个索引数据库表中以便快速检索。 5. 创世区块 创世区块即区块链的第一个区块，每一个节点都“知道”创世区块的哈希值、结构、被创建的时间和里面的一个交易。因此，每个节点都把该区块作为区块链的首区块，从而构建了一个安全的、可信的区块链的根。 创世区块的哈希值为： 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f 也可在https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f查询。 在命令行使用比特币核心客户端： $ bitcoind getblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f { \"hash\":\"000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\", \"confirmations\":308321, \"size\":285, \"height\":0, \"version\":1, \"merkleroot\":\"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\", \"tx\":[\"4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"], \"time\":1231006505, \"nonce\":2083236893, \"bits\":\"1d00ffff\", \"difficulty\":1.00000000, \"nextblockhash\":\"00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048\" } 6. 区块的连接 比特币的完整节点保存了区块链从创世区块起的一个本地副本（类似Git的本地代码仓库副本），对于新接受的 区块，本地节点先验证该区块，如果验证通过则将该区块加入到该区块链中。为建立一个连接，一个节点将检查传入的区块头并寻找该区块的“父区块哈希值”。 示例： 本地副本有277,314个区块，最后的区块（即第277,314个区块）的区块头哈希值为00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249。 新接收的区块信息如下： { \"size\":43560, \"version\":2, \"previousblockhash\":\"00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249\", \"merkleroot\":\"5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d\", \"time\":1388185038, \"difficulty\":1180923195.25802612, \"nonce\":4215469401, \"tx\":[\"257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77\", #[...many more transactions omitted...] \"05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634\" ] } 对于这一新的区块，节点会在“父区块哈希值”字段里找出包含它的父区块的哈希值。这是节点已知的哈希值，也就是第277314块区块的哈希值。故这个区块是这个链条里的最后一个区块的子区块，因此现有的区块链得以扩展。节点将新的区块添加至链条的尾端，使区块链变长到一个新的高度277,315。 示意图： 区块通过引用父区块的区块头哈希值的方式，以链条的形式进行相连 图片 - block-link 7. Merkle 树 Merkle树是一种哈希二叉树，它是一种用作快速归纳和校验大规模数据完整性的数据结构。 在比特币网络中，Merkle树被用来归纳一个区块中的所有交易，同时生成整个交易集合的数字指纹，且提供了一种校验区块是否存在某交易的高效途径。 7.1. Merkle树的生成逻辑 生成一棵完整的Merkle树方式：需要递归地对哈希节点对进行哈希，并将新生成的哈希节点插入到Merkle树中，直到只剩一个哈希节点，该节点就是Merkle树的根，根节点为32字节。在比特币的Merkle树中两次使用到了SHA256算法，因此其加密哈希算法也被称为double-SHA256。 示例： 从A、B、C、D四个交易生成一个完整的Merkle树。 步骤： 每个交易哈希化。 H~A~ = SHA256(SHA256(交易A)) 相邻叶子节点哈希生成父节点。 H~AB~=SHA256(SHA256(H~A~ + H~B~)) 依次类推，直到生成根节点（Merkle根）。 如果是奇数个交易则复制最后一个交易，凑成偶数个交易，并按上述方式生成。 H~CC~=SHA256(SHA256(H~C~ + H~C~)) 示意图： 偶数个交易（A、B、C、D）的Merkle树: 奇数个交易（A、B、C）的Merkle树: 最后一个交易C被复制两份，参与生成Merkle树 7.2. Merkle树的校验逻辑 示例： 证明某区块中存在交易K。 生成一条路径，该路径有4个哈希值（由蓝色标注）HL、HIJ、HMNOP和HABCDEFGH。由这4个哈希值产生的认证路径，再通过计算另外四对哈希值HKL、HIJKL、HIJKLMNOP和Merkle树根（由虚线标注），任何节点都能证明HK（在图中由绿色标注）包含在Merkle根中。 图片 - merkle3 7.3. Merkle树的效率 当N个数据元素经过加密后插入Merkle树时，你至多计算2*log2(N)次就能检查出任意某数据元素是否在该树中，这使得该数据结构非常高效。 交易数量 区块的近似大小 路径大小（哈希数量） 路径大小（字节） 16笔交易 4KB 4个哈希 128字节 512笔交易 128KB 9个哈希 288字节 2048笔交易 512KB 11个哈希 352字节 65,535笔交易 16MB 16个哈希 512字节 当区块大小由16笔交易（4KB）急剧增加至65,535笔交易（16MB）时，交易存在的Merkle路径长度增长极其缓慢，仅仅从128字节到512字节。 8. Merkle树和简单支付验证（SPV） 一个节点能够仅下载区块头（80字节/区块），然后通过从一个满节点回溯一条小的Merkle路径就能认证一笔交易的存在，而不需要存储或者传输大量区块链中大多数内容，这些内容可能有几个G的大小。 这种不需要维护一条完整的区块链的节点，又被称作简单支付验证（SPV）节点，SPV节点不保存所有交易也不会下载整个区块，仅仅保存区块头。它们使用认证路径或者Merkle路径来验证交易存在于区块中，而不必下载区块中所有交易。Merkle树被SPV节点广泛使用。 参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch09.asciidoc Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"blockchain/mining-and-consensus.html":{"url":"blockchain/mining-and-consensus.html","title":"挖矿与共识","keywords":"","body":"区块链系列（九）之挖矿与共识 1. 简介 挖矿的过程是产生比特币的过程，即发行比特币的过程（类似中央银行的货币发行）。挖矿同时还保护着比特币系统的安全，防止欺诈交易，避免“双重支付”，双重支付是指多次花费同一笔比特币。 挖矿的过程： 每十分钟产生一个新区块。 矿工们争相完成一道基于加密哈希算法的数学难题[工作量证明]。 算出的矿工有权在区块链上记录交易（确认交易）[去中心化结算]。 交易经确认后，新的拥有者才能在之后花费这些比特币。 挖矿的激励机制： 创建新区块的新币奖励 区块链中所含的交易费 挖矿机制特点： 发行速度为指数递减模式：新区块得到的比特币数量每210,000个块（大约四年）减少一半。 起始时间为2009年1月每个区块奖励50个比特币。 2016年每个新区块奖励12.5个比特币。 2140年所有比特币（20,999,999.98）全部发行完毕，不会再有新的比特币产生，矿工收益则主要为交易费。 挖矿的目的： 挖矿是一种去中心化结算(形成共识)的过程，每个结算所对处理的交易进行验证和结算。挖矿保护了比特币系统的安全，实现了在没有中心机构的情况下，也能使整个比特币网络达成共识。 而挖矿产生的比特币作为激励方式是手段，并不是目的，即挖矿不是为了产生比特币而是为了达成共识，形成去中心化结算。 1.1. 比特币经济学和货币创造 通过创造出新区块，比特币以一个确定的但不断减慢的速率被发行出来。大约每十分钟产生一个新区块，每一个新区块都伴随着一定数量从无到有的全新比特币。总量有限并且发行速度递减创造了一种抗通胀的货币供应模式。法币可被中央银行无限制地印刷出来，而比特币永远不会因超额印发而出现通胀。 比特币发行总量的计算脚本[max_money.py] # 初始的块奖励为50BTC start_block_reward = 50 # 以10分钟为一个区块的间隔，210000个块共约4年时间 reward_interval = 210000 def max_money(): # 50 BTC = 50 0000 0000 Satoshis current_reward = 50 * 10**8 total = 0 while current_reward > 0: total += reward_interval * current_reward current_reward /= 2 return total print \"Total BTC to ever be created:\", max_money(), \"Satoshis\" 运行 max_money.py 脚本 $ python max_money.py Total BTC to ever be created: 2099999997690000 Satoshis 比特币货币供应量曲线图 图片 - bitcoin-supply 通货紧缩货币 通缩是一种由于货币的供应和需求不匹配导致的货币增值的现象。它与通胀相反，价格通缩意味着货币随着时间有越来越强的购买力。 比特币最重要并且最有争议的一个结论是一种事先确定的发行速率递减的货币发行模式会导致货币通货紧缩（简称通缩）。 2. 去中心化共识 比特币没有中心化的机构，几乎所有节点都有一份公共总账的副本，由所有节点按照某种规则共同维护该账簿。 比特币的主要特点就是去中心化的自发共识机制，自发即没有明确的选举和固定的达成共识的时间，由所有节点按照某种规则异步交互形成。 去中心化共识主要由4种独立过程相互作用产生： 独立验证：每个全节点依据综合标准对每个交易独立验证 独立打包：通过完成工作量证明算法的验算，挖矿节点将交易记录独立打包进新区块 独立装块：每个节点独立对新区块进行校验并组装进区块链 独立选链：每个节点对区块链进行独立选择，在工作量证明机制下选择累计工作量最大的区块链(最长链原则) 3. 交易的独立校验 钱包软件通过收集UTXO、提供正确的解锁脚本、构造支付给接收者的输出这一系列的方式来创建交易。产生的交易随后将被发送到比特币网络临近的节点，从而使得该交易能够在整个比特币网络中传播。 在交易传递到临近的节点前，每一个收到交易的比特币节点将会首先验证该交易，只有有效的交易才会在网络中传播，而无效的交易将会在第一个节点处被废弃，并以接收时的相应顺序，为有效的新交易建立一个池（交易池）。 校验标准： 交易的语法和数据结构必须正确。 输入与输出列表都不能为空。 交易的字节大小是小于MAX_BLOCK_SIZE的。 每一个输出值，以及总量，必须在规定值的范围内 （小于2,100万个币，大于0）。 没有哈希等于0，N等于-1的输入（coinbase交易不应当被中继）。 nLockTime是小于或等于INT_MAX的。 交易的字节大小是大于或等于100的。 交易中的签名数量应小于签名操作数量上限。 解锁脚本（scriptSig）只能够将数字压入栈中，并且锁定脚本（scriptPubkey）必须要符合isStandard的格式 （该格式将会拒绝非标准交易）。 池中或位于主分支区块中的一个匹配交易必须是存在的。 对于每一个输入，如果引用的输出存在于池中任何的交易，该交易将被拒绝。 对于每一个输入，在主分支和交易池中寻找引用的输出交易。如果输出交易缺少任何一个输入，该交易将成为一个孤立的交易。如果与其匹配的交易还没有出现在池中，那么将被加入到孤立交易池中。 对于每一个输入，如果引用的输出交易是一个coinbase输出，该输入必须至少获得COINBASE_MATURITY (100)个确认。 对于每一个输入，引用的输出是必须存在的，并且没有被花费。 使用引用的输出交易获得输入值，并检查每一个输入值和总值是否在规定值的范围内 （小于2100万个币，大于0）。 如果输入值的总和小于输出值的总和，交易将被中止。 如果交易费用太低以至于无法进入一个空的区块，交易将被拒绝。 每一个输入的解锁脚本必须依据相应输出的锁定脚本来验证。 4. 挖矿节点 在比特币网络中，一些节点被称为专业节点矿工。对于新区块，挖矿节点竞争挖矿，如果竞争获胜则立即参与下一个新区块的挖矿中，以此循环。 5. 整合交易至区块 验证交易后，比特币节点会将这些交易添加到自己的内存池中。内存池也称作交易池，用来暂存尚未被加入到区块的交易记录。之后会将交易整合到一个候选区块中。 5.1. 交易块龄、矿工费和优先级 比特币节点需要为内存池中的每笔交易分配一个优先级，并选择较高优先级的交易记录来构建候选区块。交易的优先级是由交易输入所花费的UTXO的块龄决定，交易输入值高、“块龄”大的交易比那些新的、输入值小的交易拥有更高的优先级。如果区块中有足够的空间，高优先级的交易行为将不需要矿工费。 交易的优先级是通过输入值和输入的“块龄”乘积之和除以交易的总长度得到的： Priority = Sum (Value of input * Input Age) / Transaction Size 其中： 交易输入的值是由比特币单位“聪”（1亿分之1个比特币）来表示的。 UTXO的块龄是自该UTXO被记录到区块链为止所经历过的区块数，即这个UTXO在区块链中的深度。 交易记录的大小由字节来表示。 区块中存储交易的规则： 区块中用来存储交易的前50K字节是保留给较高优先级交易的。 然后优先选择矿工费高的交易来填充剩下的区块，区块大小上限为MAX_BLOCK_SIZE。 如区块中仍有剩余空间，挖矿节点可以选择那些不含矿工费的交易，也可能忽略这些交易。 在区块被填满后，内存池中的剩余交易会成为下一个区块的候选交易，这些交易由于块龄增大，下次打块的优先级也会增大。 比特币交易中没有过期、超时的概念，一笔交易现在有效，那么它就永远有效。 5.2. 创币交易 区块中的第一笔交易是笔特殊交易，称为创币交易或者coinbase交易。与常规交易不同，创币交易没有输入，不消耗UTXO。它只包含一个被称作coinbase的输入，仅仅用来创建新的比特币。创币交易有一个输出，支付到这个矿工的比特币地址。 例如： $ bitcoin-cli getrawtransaction d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f 1 创币交易 { \"hex\" : \"01000000010000000000000000000000000000000000000000000000000000000000000000ffffffff0f03443b0403858402062f503253482fffffffff0110c08d9500000000232102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac00000000\", \"txid\" : \"d5ada064c6417ca25c4308bd158c34b77e1c0eca2a73cda16c737e7424afba2f\", \"version\" : 1, \"locktime\" : 0, \"vin\" : [ { \"coinbase\" : \"03443b0403858402062f503253482f\", \"sequence\" : 4294967295 } ], \"vout\" : [ { \"value\" : 25.09094928, \"n\":0, \" scriptPubKey\" : { \"asm\" : \"02aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21OP_CHECKSIG\", \"hex\" : \"2102aa970c592640d19de03ff6f329d6fd2eecb023263b9ba5d1b81c29b523da8b21ac\", \"reqSigs\" : 1, \"type\" : \"pubkey\", \"addresses\" : [ \"1MxTkeEP2PmHSMze5tUZ1hAV3YTKu2Gh1N\" ] } } ], \"blockhash\" : \"0000000000000001b6b9a13b095e96db41c4a928b97ef2d944a9b31b2cc7bdc4\", \"confirmations\" : 35566, \"time\" : 1388185914, \"blocktime\" : 1388185914 } 5.3. Coinbase奖励与矿工费 为了构造创币交易，节点需要计算矿工费的总额，将已添加到区块交易的输入和输出分别进行加总，然后用输入总额减去输出总额得到矿工费总额，公式如下： Total Fees = Sum(Inputs) - Sum(Outputs) 5.4. 创币交易的结构 创币交易的结构比较特殊，与一般交易输入需要指定一个先前的UTXO不同，它包含一个“coinbase“输入。在创币交易中，“交易哈希”字段32个字节全部填充0，“交易输出索引”字段全部填充0xFF(十进制的255)，这两个字段的值表示不引用UTXO。“解锁脚本”由coinbase数据代替，数据可以由矿工自定义。 “普通交易“输入的结构 长度 字段 描述 32 字节 交易哈希 指向包含有将要被花费UTXO的交易 4 字节 交易输出索引 UTXO在交易中的索引，0 从0开始计数 1-9 字节 解锁脚本长度 解锁脚本的长度 (VarInt) 可变长度 Unlocking-Script 一段脚本，用来解锁UTXO锁定脚本中的条件 4 bytes 顺序号 当前未启用的TX替换功能，设置为0xFFFFFFFF “创世交易”输入的结构 长度 字段 描述 32 字节 交易哈希 不引用任何一个交易，值全部为0 4 字节 交易输出索引 值全部为1 1-9 字节 Coinbase数据长度 coinbase数据长度 (VarInt) 可变长度 Coinbase数据 在v2版本的区块中，除了需要以区块高度开始外，其他数据可以任意填写，用于extra nonce和挖矿标签 4 bytes 顺序号 值全部为1，0xFFFFFFFF 5.5. Coinbase数据 创币交易不包含“解锁脚本“(又称作 scriptSig)字段，这个字段被coinbase数据替代，长度最小2字节，最大100字节。除了开始的几个字节外，矿工可以任意使用coinbase的其他部分，随意填充任何数据。 6. 构造区块头 为了构造区块头，挖矿节点需要填充六个字段 区块头的结构 长度 字段 描述 4 字节 版本 版本号，用来跟踪软件或协议的升级 32 字节 前区块哈希 链中前一个区块（父区块）的哈希值 32 字节 Merkle根 一个哈希值，表示这个区块中全部交易构成的merkle树的根 4 字节 时间戳 以Unix纪元开始到当下秒数记录的区块生成的时刻 4 bytes 难度目标 该区块的工作量证明算法难度目标 4 bytes Nonce 一个用于工作量证明算法的计数器 区块头中的merkle根字段，需要将全部的交易组成一个merkle树，创币交易作为区块的首个交易，其他交易在其后，如果是奇数个交易则复制最后一个交易组成偶数个交易，最后生成merkle根的值。 挖矿的目标是找到一个使区块头哈希值小于难度目标的nonce。挖矿节点通常需要尝试数十亿甚至数万亿个不同的nonce取值，直到找到一个满足条件的nonce值。 7. 构建区块 挖矿就是重复计算区块头的哈希值，不断修改该参数，直到与哈希值匹配的一个过程。哈希函数的结果无法提前得知，也没有能得到一个特定哈希值的模式。哈希函数的这个特性意味着：得到哈希值的唯一方法是不断的尝试，每次随机修改输入，直到出现适当的哈希值。 7.1. 工作量证明算法 哈希函数的特点： 输入的数据可以是任意长度 输出的数据为固定长度 不同输入得到不同输出，相同输入得到相同输出 几乎不可能通过输出来反推出输入（不同哈希函数安全性可能不同） 比特币一般采用的哈希函数为SHA256函数（输出总是256位的长度），工作量证明过程可简化为如下数学问题： 找出一个 $x$ 使得满足 $f(x,x_0) 由于$f(x,x_0)$ 是一个单向哈希函数，即无法通过 $y_0$ 反向求出 $x$，所以需要不断地尝试 $x$ 从而得出 $f(x,x_0)$与目标值 $y_0$ 比较来判断该 $x_0$ 是否为所要找的Nonce值。 例如： 假设$x_0$为I am Satoshi Nakamoto，$x$为某个数字（即Nonce值），通过不断更改$x$ 的值，将$x$添加到$x_0$末尾并计算其哈希值，直到找到一个$x$使得得出的哈希值的十六进制表示以0开头（即target值）。 $ python hash_example.py I am Satoshi Nakamoto0 => a80a81401765c8eddee25df36728d732... I am Satoshi Nakamoto1 => f7bc9a6304a4647bb41241a677b5345f... I am Satoshi Nakamoto2 => ea758a8134b115298a1583ffb80ae629... I am Satoshi Nakamoto3 => bfa9779618ff072c903d773de30c99bd... I am Satoshi Nakamoto4 => bce8564de9a83c18c31944a66bde992f... I am Satoshi Nakamoto5 => eb362c3cf3479be0a97a20163589038e... I am Satoshi Nakamoto6 => 4a2fd48e3be420d0d28e202360cfbaba... I am Satoshi Nakamoto7 => 790b5a1349a5f2b909bf74d0d166b17a... I am Satoshi Nakamoto8 => 702c45e5b15aa54b625d68dd947f1597... I am Satoshi Nakamoto9 => 7007cf7dd40f5e933cd89fff5b791ff0... I am Satoshi Nakamoto10 => c2f38c81992f4614206a21537bd634a... I am Satoshi Nakamoto11 => 7045da6ed8a914690f087690e1e8d66... I am Satoshi Nakamoto12 => 60f01db30c1a0d4cbce2b4b22e88b9b... I am Satoshi Nakamoto13 => 0ebc56d59a34f5082aaef3d66b37a66... # 得出的哈希值以0开头 I am Satoshi Nakamoto14 => 27ead1ca85da66981fd9da01a8c6816... 通过以上例子可以看出，其中$x$为13得出的哈希值为0ebc56d59a34f5082aaef3d66b37a66...是满足要求的，即13就是一个满足条件的Nonce值。 同理当target值不断减小，即以0开头的位数增加，则找到该Nonce值的难度也随之增大。 7.2. 难度表示 难度值查询网址：https://bitcoinwisdom.com/bitcoin/difficulty 7.3. 难度目标与难度调整 比特币的区块平均每10分钟生成一个。是货币发行速率和交易达成速度的基础。 计算机性能会不断增长，即挖矿能力会不断提升，难度的调整可以确保新区块产生速度始终稳定在10分钟1个。难度值的调整是自动发生的，依据以下公式。 New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes) 难度的调整公式是由最新2,016个区块的花费时长与20,160分钟（两周，即这些区块以10分钟一个速率所期望花费的时长）比较得出的。如果网络发现区块产生速率比10分钟要快时会增加难度。如果发现比10分钟慢时则降低难度。目标难度与交易的数量和金额无关。 8. 成功构建区块 当某个挖矿节点找到满足条件的Nonce值后，会立刻将这个区块发给它的所有相邻节点。这些节点在接收并验证这个新区块后，也会继续传播此区块。当这个新区块在网络中扩散时，每个节点都会将它作为区块277,316加到自身节点的区块链副本中。当挖矿节点收到并验证了这个新区块后，它们会放弃之前对构建这个相同高度区块的计算，并立即开始计算区块链中下一个区块的工作。 9. 校验新区块 每个节点独立校验每个新区块。当新区块在网络中传播时，每一个节点在将它转发到其节点之前，会进行一系列的测试去验证它。这确保了只有有效的区块会在网络中传播。独立校验还确保了诚实的矿工生成的区块可以被纳入到区块链中，从而获得奖励。行为不诚实的矿工所产生的区块将被拒绝，这不但使他们失去了奖励，而且也浪费了本来可以去寻找工作量证明解的机会，因而导致其电费亏损。 验证区块的内容： 区块的数据结构语法上有效 区块头的哈希值小于目标难度（确认包含足够的工作量证明） 区块时间戳早于验证时刻未来两个小时（允许时间错误） 区块大小在长度限制之内 第一个交易（且只有第一个）是coinbase交易 使用检查清单验证区块内的交易并确保它们的有效性 “交易的独立校验”一节已经讨论过这个清单。 10. 区块链的组装与选择 比特币去中心化共识的最后一步是将区块合到最长链中（即有最大工作量证明的链），如果某个节点验证了新的区块，它将尝试将新的区块连接到现有的区块链中，如果验证过程失败，则该区块会被节点拒绝，不会加入链中。 节点维护三种区块： 连接到主链的 从主链上产生分叉的备用链 在已知链中未找到已知父区块的 10.1. 区块链分叉 分叉的发生： 分叉发生在两名矿工在较短的时间内，各自都算得了工作量证明解的时候。两个矿工在各自的候选区块一发现解，便立即传播自己的“获胜”区块到网络中，先是传播给邻近的节点而后传播到整个网络。每个收到有效区块的节点都会将其并入并延长区块链。如果该节点在随后又收到了另一个候选区块，而这个区块又拥有同样父区块，那么节点会将这个区块连接到候选链上。其结果是，一些节点收到了一个候选区块，而另一些节点收到了另一个候选区块，这时两个不同版本的区块链就出现了。 分叉的解决： 解决的办法是，每一个节点总是选择并尝试延长代表累计了最大工作量证明的区块链，也就是最长的或最大累计难度的链。节点通过将记录在每个区块中的难度加总起来，得到建立这个链所要付出的工作量证明的总量。只要所有的节点选择最长累计难度的区块链，整个比特币网络最终会收敛到一致的状态。 11. 共识攻击 待完成 文章参考： Mastering Bitcoin https://github.com/bitcoinbook/bitcoinbook/blob/develop/ch10.asciidoc Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"blockchain/consensus-algorithm.html":{"url":"blockchain/consensus-algorithm.html","title":"共识算法","keywords":"","body":"区块链之共识算法 本文主要说明常用的几种共识算法 1. 拜占庭容错技术 区块链的架构是一种分布式架构，其中公有链、联盟链、私有链，分别对应去中心化分布式系统、部分去中心化分布式系统和弱中心化分布式系统。 在分布式系统中，可能存在故障主机、网络拥塞等问题导致错误信息在系统中传播，因此需要在默认不可靠的异步网络中定义容错协议来保证各主机达到安全可靠的状态共识。其中拜占庭容错技术是一类分布式系统中的容错技术。 1.1. 拜占庭将军问题 问题描述：拜占庭将军问题就是寻找一个方法使得在有叛徒的非信任环境中建立对战斗计划的共识。 2. PoW机制 PoW（Proof of Work），即工作量证明，可理解为当你达到某个水平，表明了你付出了对应的工作量。例如你获得了毕业证，表明你已经完成了大学所有课程的工作量。在比特币系统中，当你找到了某个满足当前难度的Nonce值（即挖矿），表明了你付出了相应计算量。 工作量证明函数：表示计算方法 区块：表示输入数据 难度值：表示所需计算量 2.1. 工作量证明函数 比特币系统中使用的工作量证明函数是SHA256，其输出值为256位的哈希算法。 2.2. 区块 比特币的区块由区块头和该区块所包含的交易列表组成。区块头的大小为80字节，作为比特币工作量证明函数的输入字符串，为了体现包含区块的所有交易，区块头中包含一个所有交易的生成的Merkle根的哈希值。同时区块头还包含了父区块的哈希值，从而将记录不同交易的区块关联起来，形成区块链。 2.3. 难度值 难度值决定了节点大概多久产生一个合法的区块，即根据算力的不同，适当地调整难度值使得新区块的产生速度稳定在一个固定的速率（例如10分钟产生一个新区块）。其中难度值的调整是在每个完整节点中按照统一的公式自动发生的。 公式如下： 新难度值=旧难度值*（过去2016个区块花费时长/20160分钟） 目标值：即挖矿产生的区块哈希值必须小于目标值。 目标值=最大目标值/难度值 其中最大目标值是一个恒定值，即目标值与难度值成反比。 2.4. PoW的过程 PoW的过程可以简化为以下数学问题： 找出一个 $x$ 使得满足 $f(x,x_0) 由于$f(x,x_0)$ 是一个单向哈希函数，即无法通过 $y_0$ 反向求出 $x$，所以需要不断地尝试 $x$ 从而得出 $f(x,x_0)$与目标值 $y_0$ 比较来判断该 $x_0$ 是否为所要找的Nonce值。 具体过程： 生成coinbase交易，并和其他需要打包进块的交易组成交易列表，将交易列表通过Merkle算法生成Merkle根哈希值。 把Merkle根哈希值和其他必要字段（例如父区块哈希值等）组成区块头，将区块头的80字节数据作为工作量证明函数的输入。 不断改变区块头中的Nonce值，对改变后的区块头进行双重SHA256运算（即SHA256(SHA256(Block_Header))），如果结果值小于当前的目标值则计算成功，即挖矿成功。 2.5. 基于PoW的共识记账 以下以比特币为例说明基于PoW的共识记账过程。 客户端产生新的交易，向全网广播要求对交易进行记账。 每个记账节点一收到请求就将该交易信息纳入一个区块中。 每个节点通过PoW的过程，找到符合难度的Nonce值，即挖矿。 当某个节点找到该Nonce值（即工作量证明），就向全网广播。 当且仅当该区块的所有交易有效且之前未存在过，才认证该区块有效。 其他节点认可了该区块则将区块加在自己区块链的末尾，并进行下一个区块的挖矿过程。 2.6. PoW与拜占庭问题 待完成 3. PoS机制 PoS(Proof of Stake)，即权益证明。PoS指的是一种对货币所有权的证明。一笔交易所消耗的币龄可被视为PoS的一种形式。 待完成 4. DPoS机制 DPoS(Delegated Proof of Stake)，即股份授权证明。 待完成 Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"ethereum/ethereum-introduction.html":{"url":"ethereum/ethereum-introduction.html","title":"以太坊介绍","keywords":"","body":"以太坊系列（一）之以太坊介绍 1. 以太坊的介绍 以太坊是一个开放的区块链平台，允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用，同比特币一样，以太坊由全球范围的很多人共同创建，不受任何个人控制。 2. 下一代区块链 区块链技术是比特币的底层技术。在比特币中，分布式数据库被设想为一个账户余额表（总账），交易通过比特币的转移来实现个体之间无需信任基础的金融活动。以太坊试图实现一个总体上完全无需信任基础的智能合约平台。 3. 以太坊虚拟机 以太坊是可编程的区块链，不会给用户一系列预先设置好的操作，允许用户自定义复杂的操作。以太坊狭义上是指一系列定义去中心化应用平台的协议，核心是以太坊虚拟机（EVM），其可以执行任意复杂算法的编码。以太坊是图灵完备的。 以太坊也有一个点对点的网络协议，以太坊区块链数据库由各网络节点来维护和更新，每个节点运行以太坊虚拟机并执行相同的指令，保证区块链的一致性。 4. 以太坊工作原理 比特币可以看作是关于交易的列表，而以太坊的基础单元是账户。以太坊跟踪每个账户的状态，以太坊上所有状态转换都是账户之间价值和信息的转换。 账户分为两类： 外部账户（EOA）：由私人密钥控制 合约账户：由合约代码控制，只能由外部账户“激活”。 智能合约：指合约账户中的编码，即交易被发送给该账户时所运行的程序。用户可以通过在区块链中部署编码来创建新的合约。 只有当外部账户发出指令时，合约账户才会执行相应的操作，是为了保证正确执行所有操作。 和比特币一样，以太坊用户需要向网络支付少量的交易费用，通过以太币的形式支付。这样避免受到类似DDos的攻击。 交易费用由节点收集，节点使网络生效。“矿工”就是以太坊网络中收集、传播、确认和执行交易的节点。矿工将交易打包，打包的数据成为区块，打包的过程就是将以太坊中账户的状态更新的过程。矿工们相互竞争挖矿，成功挖矿的可以得到以太币的奖励。 参考： http://www.ethdocs.org/en/latest/introduction/what-is-ethereum.html Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "},"ethereum/ethereum-account-management.html":{"url":"ethereum/ethereum-account-management.html","title":"账户管理","keywords":"","body":"以太坊系列（二）之账户管理 1. 账户 以太坊有两种账户类型： 外部账户（EOA） 合约账户 所有账户的状态代表以太坊网络的状态，以太坊网络会和每一个区块一起更新，网络需要达成关于以太坊的共识。账户代表外部代理人的身份，账户运用非对称加密的私钥来签署交易，以便以太坊虚拟机可以安全验证交易发送者的身份。 2. 钥匙文件(Keyfiles) 每个账户都由一对密钥来定义，包括公钥和私钥。账户以地址为索引，地址由公钥生成，每对私钥/地址都编码在一个钥匙文件（JSON文件）中，其中最重要的为账户私钥，通常用创建账户时的密码加密。可以在以太坊节点数据目录的keystore子目录下找到钥匙文件。 3. 创建账户 为了从账户发送交易包括以太币，需要拥有Keyfiles和密码。需要记住并备份钥匙文件，没有“找回密码”的选项。 3.1. 使用geth account new geth是以太坊的go语言客户端。创建账户只需要执行geth account new命令。 3.1.1. 下载安装 # 下载源码 git clone https://github.com/ethereum/go-ethereum.git # 编译 cd go-ethereum make geth # 编译后会在`go-ethereum/build/bin/`目录下生成二进制文件，拷贝到$PATH路径下 cp build/bin/geth /usr/local/bin/ # 验证 geth --help go的版本最好在1.9.2及以上版本，否则编译可能报以下错误 ... # github.com/ethereum/go-ethereum/vendor/gopkg.in/olebedev/go-duktape.v3 vendor/gopkg.in/olebedev/go-duktape.v3/duktape.go:133: constant 18446744073709551615 overflows int64 util.go:45: exit status 2 exit status 1 make: *** [all] Error 1 3.1.2. 创建账户 geth account new # 交互式，输入密码 $ geth account new INFO [07-09|05:06:46.393] Maximum peer count ETH=25 LES=0 total=25 Your new account is locked with a password. Please give a password. Do not forget this password. Passphrase: Repeat passphrase: Address: {df90109c1497bc6f3a0cd98cdc114ec89481447e} # 非交互式，从文件读取密码。不建议使用，容易暴露密码 $ geth --password /path/to/password account new # 例如 $ geth --password ethpasswd account new INFO [07-09|05:27:48.567] Maximum peer count ETH=25 LES=0 total=25 Address: {0ad31ccaf888cf8499de4cdfa18f8d746a1d27e7} 3.1.3. 查询账户 geth account list $ geth account list INFO [07-09|05:29:31.708] Maximum peer count ETH=25 LES=0 total=25 Account #0: {df90109c1497bc6f3a0cd98cdc114ec89481447e} keystore:///root/.ethereum/keystore/UTC--2018-07-08T21-07-05.374654217Z--df90109c1497bc6f3a0cd98cdc114ec89481447e Account #1: {0ad31ccaf888cf8499de4cdfa18f8d746a1d27e7} keystore:///root/.ethereum/keystore/UTC--2018-07-08T21-27-48.567366972Z--0ad31ccaf888cf8499de4cdfa18f8d746a1d27e7 keyfiles存储在~/.ethereum/keystore路径下，一般按照创建时间顺序排列，格式如下： $ cd .ethereum/keystore $ ls UTC--2018-07-08T21-07-05.374654217Z--df90109c1497bc6f3a0cd98cdc114ec89481447e UTC--2018-07-08T21-27-48.567366972Z--0ad31ccaf888cf8499de4cdfa18f8d746a1d27e7 keyfile的文件内容如下： $ cat UTC--2018-07-08T21-07-05.374654217Z--df90109c1497bc6f3a0cd98cdc114ec89481447e | python -m json.tool { \"address\": \"df90109c1497bc6f3a0cd98cdc114ec89481447e\", \"crypto\": { \"cipher\": \"aes-128-ctr\", \"cipherparams\": { \"iv\": \"ac945759e1e445776387eeb855df208d\" }, \"ciphertext\": \"4c75c2dcbba248e9f0f43bb4fed4ca9be10b00c02bb60ad7926f013541266592\", \"kdf\": \"scrypt\", \"kdfparams\": { \"dklen\": 32, \"n\": 262144, \"p\": 1, \"r\": 8, \"salt\": \"199c4c1129a594871e47f3be3b71d57b8e0efcd5f543b9684495f007eb51ce1c\" }, \"mac\": \"da461ede939be6509db7bf25f0b30b557d66e5edc26b9590dfbba733e4af5c7b\" }, \"id\": \"7cda7e39-1132-4b0c-aade-2aed1e845ed1\", \"version\": 3 } 3.2. 使用geth控制台 使用geth控制台创建新账户，需要在控制台模式下开启geth交互模式。 $ geth console 2>> file_to_log_output Welcome to the Geth JavaScript console! instance: Geth/v1.8.13-unstable-3b074515/linux-amd64/go1.9.4 coinbase: 0xdf90109c1497bc6f3a0cd98cdc114ec89481447e at block: 0 (Thu, 01 Jan 1970 08:00:00 CST) datadir: /root/.ethereum modules: admin:1.0 debug:1.0 eth:1.0 miner:1.0 net:1.0 personal:1.0 rpc:1.0 txpool:1.0 web3:1.0 > 3.2.1. 创建账户 personal.newAccount() > personal.newAccount() Passphrase: Repeat passphrase: \"0x06341612bc695a2cab1d294630ce44f8789efabc\" 3.2.2. 列出账户 eth.accounts > eth.accounts [\"0xdf90109c1497bc6f3a0cd98cdc114ec89481447e\", \"0x0ad31ccaf888cf8499de4cdfa18f8d746a1d27e7\", \"0x06341612bc695a2cab1d294630ce44f8789efabc\"] 4. 更新、备份、恢复账户 4.1. 更新账户 geth account update更改账户密码，需要输入原密码。 以下通过账户地址来修改密码： $ geth account update df90109c1497bc6f3a0cd98cdc114ec89481447e INFO [07-09|06:02:53.411] Maximum peer count ETH=25 LES=0 total=25 Unlocking account df90109c1497bc6f3a0cd98cdc114ec89481447e | Attempt 1/3 Passphrase: INFO [07-09|06:02:57.475] Unlocked account address=0xdF90109c1497bc6f3a0cd98cdC114Ec89481447E Please give a new password. Do not forget this password. Passphrase: Repeat passphrase: 也可以通过账户索引来修改密码： # 以下示例的账号索引为 0 $ geth account update 0 INFO [07-09|06:05:59.087] Maximum peer count ETH=25 LES=0 total=25 WARN [07-09|06:05:59.087] ------------------------------------------------------------------- WARN [07-09|06:05:59.087] Referring to accounts by order in the keystore folder is dangerous! WARN [07-09|06:05:59.087] This functionality is deprecated and will be removed in the future! WARN [07-09|06:05:59.087] Please use explicit addresses! (can search via `geth account list`) WARN [07-09|06:05:59.087] ------------------------------------------------------------------- Unlocking account 0 | Attempt 1/3 Passphrase: INFO [07-09|06:06:04.081] Unlocked account address=0xdF90109c1497bc6f3a0cd98cdC114Ec89481447E Please give a new password. Do not forget this password. Passphrase: Repeat passphrase: 可以通过--password参数修改，仍需要输入文件中的密码： geth --password ethpasswd account update 0ad31ccaf888cf8499de4cdfa18f8d746a1d27e7 INFO [07-09|06:10:16.564] Maximum peer count ETH=25 LES=0 total=25 Unlocking account 0ad31ccaf888cf8499de4cdfa18f8d746a1d27e7 | Attempt 1/3 Passphrase: INFO [07-09|06:11:04.954] Unlocked account address=0x0AD31CcAf888Cf8499de4cdFA18F8d746A1d27E7 Please give a new password. Do not forget this password. Passphrase: Repeat passphrase: 4.2. 账户备份和恢复 手动备份/恢复 要从账户发送交易需要keyfile，Linux系统中，keyfile位于~/.ethereum/keystore中。 备份keyfile：复制keystore目录下的一个或多个keyfile。 恢复keyfile：将备份的keyfile重新拷贝到keystore的目录下。 导入未加密的私钥 geth account import /path/to/ 参考： http://www.ethdocs.org/en/latest/account-management.html Copyright © www.huweihuang.com 2017-2018 all right reserved，powered by GitbookUpdated at 2022-05-16 12:51:52 "}}